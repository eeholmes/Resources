---
title: "BestPractices"
author: "Christine Stawitz"
date: "May 30, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## General principles of change management

Some principles of software management and review are true across all workflows. These are presented first; for more details on possible workflows in Github, see "Github workflow" section below.

1. The `master` branch is always stable. To ensure stability, a combination of automated testing and manual review needs to be undertaken everytime a change is merged into `master.` At minimum complete the following checklist:

- A series of unit tests are ran. Realistically, this means using a continous integration tool (we recommend TravisCI<https://docs.travis-ci.com/user/tutorial/>). Manual running of test suites at the frequency we expect changes to be merged becomes way too cumbersome. For a more basic introduction to Travis for R packages, see Julia Silge's excellent blog post <https://juliasilge.com/blog/beginners-guide-to-travis/>
- All documentation is updated. This includes auto-update of code reference documentation generated by `doxygen, sphinx`, etc. and manual examination that any changes that break example code, vignettes, or tutorials are updated in the respective materials. For `R` packages, it also means ensuring your DESCRIPTION file is updated with any new package dependencies.
- Manual code review. At least one package collaborator should review changes, suggest alternative approaches, and approve as necessary.

2. Changes in `master` are pulled to working location (this could be a development or feature branch, or fork depending on the workflow) every time the new code is tested. This ensures the remote location stays up to date.

3. Changes that are the subject of pull requests do not exceed 500 lines of code. Changes of larger magnitude are difficult to review and test in one go. Similarly, changes that are intended to be merged in should be on a weekly basis.

## Github workflow options

My main critique of Github is its tendency to provide too many parallel options that achieve the same end goal. One of these is illustrated with choosing between git forking and branching workflows. Both are legitimate workflows but it is unclear what the pros and cons of each are. My pros and cons are presented below:

# Pros of forking:
1. The only option if you intend to keep code divergent forever.
2. Does not require contributors to be added as collaborators to the project.

# Cons of forking:
1. Harder to stay up-to-date with master.
2. Harder to make "feature forks" than "feature branches."
3. Doesn't integrate quite as well with releases.

# Pros of branching:
1. Allows for multi-branch workflow, i.e. a `master`, `development`, and feature branches. Feature branches are one way to keep changes more modular and improve testability.
2. Seamless to manage Github releases.
3. Branch protection rules to enforce more protocols on everyone, including administrators.

# Cons of branching:
1. Authors need to be collaborators.
2. Not ideal for permanently divergng codebases.

For our toolbox, NOAA git policy dictates non-NOAA affiliates cannot have push access to the repository. For this reason, you can only use the branch workflow if your repository exists under an organization, which allows you to tweak the permissions of collaborators. A non-organization git repo gives all collaborators push access. We recommend creating an organization for your repository if you have more than one repository and/or more than 2 or 3 collaborators and using the branching workflow for changes you expect to be merged back into the master branch. If you expect changes to diverge and not rejoin master, or you have one repository with non-NOAA collaborators, the forking workflow may suit your needs better.  

## Avoiding duplication


